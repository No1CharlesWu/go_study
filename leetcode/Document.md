# &&&&& : 5. 6. 10
----
## &&&& : 4. 23. 28. 30
----
### &&& : 11. 15. 17. 19. 29
----
#### && : 3. 8. 12. 16. 18. 22. 25
----
##### & : 1. 2. 7. 9. 13. 14. 20. 21. 24. 26. 27.
----

1. 找出两个数相加之和等于一个固定值。 1
2. 两个用链表拼起来的数求和。 1
3. 找出最长不重复子链，字符串操作。 2
4. 找出中值，二分法一直比较中间4个值，去除多余的部分。 4
5. 最长回文子串，用 Manacher 算法，感觉是中心扩展法的升级版，利用回文中的子回文对称，记录子回文长度，简化计算另一侧的长度，减少比较，加快速度。 5
6. 之字形变形，找规律，把字符串重新排列。 5
7. Integer的倒置。 1
8. 手写 atoi ，多考虑下情况就好。 2
9. Integer 的回文比较。 1
10. 正则匹配。使用的DP求解的，主要是找到填表模式，虽然解出来了，但分治及DP的思路还是没打开，好好看这个。 5
11. 求最大的容器面积，使用双指针，左右指针夹逼的原理求得。 3
12. 数字转换成罗马字符，建表，对应数字转换即可。 2
13. 罗马字符转换成数字，建map，对应转换即可。 1
14. 找出所有字符串的公共最长前缀。很简单，就是从前往后依次比较对应字符串即可。 1
15. 从一组数中找出三个和为零的组合，先排序，再遍历数组确定一个数，用夹逼法找到另两个数，注意去重。 3
16. 从一组数中找出三个数之和与目标值最接近的数，与15题一致，还要更简单。无需去重，去重可能效果更好点。 2
17. 算是一个枚举的。用的循环，本质算是bfs。也可以用dfs解决，不难，待多种方法解决。 3
18. 从一组数中找出四个数之和等于目标值的组合，要求去重。和15题一样，就是多一层循环，无其他难度。 2
19. 删除链表倒数第n个数，要求一次遍历。方法：使用快慢指针，快指针先走n步，然后快慢指针一起走。快指针结束时，慢指针就找到了。 3
20. 括号匹配判断，简单的栈即可。go语言的list使用不流畅。待看。 1
21. 简单的合并两个有序链表。 1
22. 生成正确括号化方案，dfs递归应用。 2
23. 多个有序链表的合并。可以用最小堆来做。但是我还没用。用的是21题的合并两个链表，然后用归并做的。待用最小堆处理。 4
24. 链表中每相邻两个节点交换。简单。应用一下递归。 1
25. 已组为单位翻转K部分链表的节点。可以使用24题思想的递归，翻转用指针尾插法。 2
26. 数组的基本操作，把有序数组剔除重复部分。就是用后面非重复部分改写前面的部分即可。 另：切片在函数间传递是地址传递，但是切记不能使用append操作这个地址，不然会使改地址发生变化。 1
27. 数组的基本操作，剔除特定值的数，返回数组。 1
28. strStr()的改写。go语言可以直接比较string。学习一下。简便很多。 4
29. 不可用乘除法的两数相除。用位运算解决。 3
30. 求单词串联起来子串的位置，用map解决。原想用滑动窗口，后发现只能一个一个字符的遍历。 4
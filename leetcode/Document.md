# &&&&& : 5. 6. 10. 32. 39. 42
----
## &&&& : 4. 23. 28. 30. 33. 37. 
----
### &&& : 11. 15. 17. 19. 29. 31. 34. 40. 41. 43. 
----
#### && : 3. 8. 12. 16. 18. 22. 25
----
##### & : 1. 2. 7. 9. 13. 14. 20. 21. 24. 26. 27. 35. 36. 38.
----

1. 找出两个数相加之和等于一个固定值。 1
2. 两个用链表拼起来的数求和。 1
3. 找出最长不重复子链，字符串操作。 2
4. 找出中值，二分法一直比较中间4个值，去除多余的部分。 4
5. 最长回文子串，用 Manacher 算法，感觉是中心扩展法的升级版，利用回文中的子回文对称，记录子回文长度，简化计算另一侧的长度，减少比较，加快速度。 5
6. 之字形变形，找规律，把字符串重新排列。 5
7. Integer的倒置。 1
8. 手写 atoi ，多考虑下情况就好。 2
9. Integer 的回文比较。 1
10. 正则匹配。使用的DP求解的，主要是找到填表模式，虽然解出来了，但分治及DP的思路还是没打开，好好看这个。 5
11. 求最大的容器面积，使用双指针，左右指针夹逼的原理求得。 3
12. 数字转换成罗马字符，建表，对应数字转换即可。 2
13. 罗马字符转换成数字，建map，对应转换即可。 1
14. 找出所有字符串的公共最长前缀。很简单，就是从前往后依次比较对应字符串即可。 1
15. 从一组数中找出三个和为零的组合，先排序，再遍历数组确定一个数，用夹逼法找到另两个数，注意去重。 3
16. 从一组数中找出三个数之和与目标值最接近的数，与15题一致，还要更简单。无需去重，去重可能效果更好点。 2
17. 算是一个枚举的。用的循环，本质算是bfs。也可以用dfs解决，不难，待多种方法解决。 3
18. 从一组数中找出四个数之和等于目标值的组合，要求去重。和15题一样，就是多一层循环，无其他难度。 2
19. 删除链表倒数第n个数，要求一次遍历。方法：使用快慢指针，快指针先走n步，然后快慢指针一起走。快指针结束时，慢指针就找到了。 3
20. 括号匹配判断，简单的栈即可。go语言的list使用不流畅。待看。 1
21. 简单的合并两个有序链表。 1
22. 生成正确括号化方案，dfs递归应用。 2
23. 多个有序链表的合并。可以用最小堆来做。但是我还没用。用的是21题的合并两个链表，然后用归并做的。待用最小堆处理。 4
24. 链表中每相邻两个节点交换。简单。应用一下递归。 1
25. 已组为单位翻转K部分链表的节点。可以使用24题思想的递归，翻转用指针尾插法。 2
26. 数组的基本操作，把有序数组剔除重复部分。就是用后面非重复部分改写前面的部分即可。 另：切片在函数间传递是地址传递，但是切记不能使用append操作这个地址，不然会使改地址发生变化。 1
27. 数组的基本操作，剔除特定值的数，返回数组。 1
28. strStr()的改写。go语言可以直接比较string。学习一下。简便很多。 4
29. 不可用乘除法的两数相除。用位运算解决。 3
30. 求单词串联起来子串的位置，用map解决。原想用滑动窗口，后发现只能一个一个字符的遍历。 4
31. 求数字组合成的数，字典表顺序的下一个数，就是用现有数组合更大一点的数。 3
32. 最长括号匹配数，可以用出入栈，也可用DP，dp[i]为从头到当前位置的最长括号匹配数。时间复杂度相同。参考https://blog.csdn.net/accepthjp/article/details/52439449  5
33. 循环有序数组的二分查找法。 用的递归，写的并不好。 4
34. 有序数组搜索目标值范围，用两次二分查找法分别找出目标值的左坐标和右坐标。 3
35. 有序数组搜索目标值，或该目标值应该插入的位置。二分查找法即可。 1
36. 数独有效性检测，知道规则就好，检测每行每列每九宫格是否有重复的即可。 1
37. 数独填空题，用的最简单的暴力破解法。速度一般。如果一开始做一下检测剪枝，应该可以稍微快点。 4
38. 题目不好理解。内容是简单的字符串操作问题。 1
39. 典型的dfs求解，我居然写了这么久。笨。 5
40. 39题的升级，加个去重就好。当然一定有更清晰的思路解法，不过这个改一改也够了。 3
41. 数组内部变化的题，用桶排序思想，把元素放在他应该在的位置上。 3
42. 接水问题，网上一个思路非常好。https://blog.csdn.net/makuiyu/article/details/43650365 学习了。有一种大局观~ 5
43. 字符串大数乘法，我还是简单用了倒置字符串，一步一步的乘和加起来的。有不需要倒置更好的方法，待学习。 3